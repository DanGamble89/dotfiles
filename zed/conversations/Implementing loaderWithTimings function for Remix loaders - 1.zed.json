{"id":"c40ef68c-93c8-4724-b1b4-ed0a82892d85","zed":"context","version":"0.4.0","text":"\n\n```ts omorovicza-app/app/utils/timings/index.server.ts\nimport type { CreateReporter } from \"@epic-web/cachified\";\nimport type { LoaderFunctionArgs } from \"@remix-run/cloudflare\";\n\nexport type Timings = Record<\n\tstring,\n\tArray<\n\t\t{ desc?: string } & (\n\t\t\t| { time: number; start?: never }\n\t\t\t| { time?: never; start: number }\n\t\t)\n\t>\n>;\n\nexport function makeTimings(type: string, desc?: string) {\n\tconst timings: Timings = {\n\t\t[type]: [{ desc, start: performance.now() }],\n\t};\n\tObject.defineProperty(timings, \"toString\", {\n\t\tvalue() {\n\t\t\treturn getServerTimeHeader(timings);\n\t\t},\n\t\tenumerable: false,\n\t});\n\n\treturn timings;\n}\n\nfunction createTimer(type: string, desc?: string) {\n\tconst start = performance.now();\n\n\treturn {\n\t\tend(timings: Timings) {\n\t\t\tlet timingType = timings[type];\n\n\t\t\tif (!timingType) {\n\t\t\t\t// eslint-disable-next-line no-multi-assign\n\t\t\t\ttimingType = timings[type] = [];\n\t\t\t}\n\n\t\t\ttimingType.push({ desc, time: performance.now() - start });\n\t\t},\n\t};\n}\n\nexport async function time<ReturnType>(\n\tfn: Promise<ReturnType> | (() => ReturnType | Promise<ReturnType>),\n\t{\n\t\ttype,\n\t\tdesc,\n\t\ttimings,\n\t}: {\n\t\ttype: string;\n\t\tdesc?: string;\n\t\ttimings?: Timings;\n\t},\n): Promise<ReturnType> {\n\tconst timer = createTimer(type, desc);\n\tconst promise = typeof fn === \"function\" ? fn() : fn;\n\tif (timings == null) return promise;\n\n\tconst result = await promise;\n\n\ttimer.end(timings);\n\treturn result;\n}\n\nexport function getServerTimeHeader(timings?: Timings) {\n\tif (timings == null) return \"\";\n\treturn Object.entries(timings)\n\t\t.map(([key, timingInfos]) => {\n\t\t\tconst dur = timingInfos\n\t\t\t\t.reduce((acc, timingInfo) => {\n\t\t\t\t\tconst time = timingInfo.time ?? performance.now() - timingInfo.start;\n\t\t\t\t\treturn acc + time;\n\t\t\t\t}, 0)\n\t\t\t\t.toFixed(2);\n\t\t\tconst desc = timingInfos\n\t\t\t\t.map((t) => t.desc)\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.join(\" & \");\n\t\t\treturn [\n\t\t\t\tkey.replaceAll(/(:| |@|=|;|,|\\/|\\\\)/g, \"_\"),\n\t\t\t\tdesc ? `desc=${JSON.stringify(desc)}` : null,\n\t\t\t\t`dur=${dur}`,\n\t\t\t]\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.join(\";\");\n\t\t})\n\t\t.join(\",\");\n}\n\nexport function combineServerTimings(headers1: Headers, headers2: Headers) {\n\tconst newHeaders = new Headers(headers1);\n\tnewHeaders.append(\"Server-Timing\", headers2.get(\"Server-Timing\") ?? \"\");\n\n\treturn newHeaders.get(\"Server-Timing\") ?? \"\";\n}\n\nexport function cachifiedTimingReporter<Value>(\n\ttimings?: Timings,\n): undefined | CreateReporter<Value> {\n\tif (timings == null) return;\n\n\treturn ({ key }) => {\n\t\tconst cacheRetrievalTimer = createTimer(\n\t\t\t`cache:${key}`,\n\t\t\t`${key} cache retrieval`,\n\t\t);\n\t\tlet getFreshValueTimer: ReturnType<typeof createTimer> | undefined;\n\n\t\treturn (event) => {\n\t\t\tswitch (event.name) {\n\t\t\t\tcase \"getFreshValueStart\":\n\t\t\t\t\tgetFreshValueTimer = createTimer(\n\t\t\t\t\t\t`getFreshValue:${key}`,\n\t\t\t\t\t\t`request forced to wait for a fresh ${key} value`,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"getFreshValueSuccess\":\n\t\t\t\t\tgetFreshValueTimer?.end(timings);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"done\":\n\t\t\t\t\tcacheRetrievalTimer.end(timings);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t};\n}\n\nexport async function loaderWithTimings<Data> (timingsKey: string, dataFn: (time: ) => Promise<Data>) {\n\tconst timings = makeTimings(timingsKey);\n\n\tasync function localTime<ReturnType>(\n\t\tfn: Promise<ReturnType> | (() => ReturnType | Promise<ReturnType>),\n\t\ttype: string,\n\t\tdesc?: string\n\t) {\n\t\treturn time(fn, { timings, type, desc })\n\t}\n\n\treturn async function loader ({ context, request }: LoaderFunctionArgs) {\n\n\t}\n}\n```\ndiagnostics: omorovicza-app/app/utils/timings/index.server.ts\n```typescript\n}\n\nexport async function loaderWithTimings<Data> (timingsKey: string, dataFn: (time: ) => Promise<Data>) {\n// error: Type expected.\n\tconst timings = makeTimings(timingsKey);\n\n```\n\nHow would I create this `loaderWithTimings` function that can be used as a remix loader like `export const loader = loaderWithTimings(\"myKey\", (time, { context, request }) => {})` and have the callback typed properly? The `time` argument should be the type of the `localTime` function within the `loaderWithTimings` function\n\nTo create the `loaderWithTimings` function as you described, you'll need to modify the function signature and implementation. Here's how you can do it:\n\n```typescript\nexport function loaderWithTimings<Data>(\n  timingsKey: string,\n  dataFn: (\n    time: <ReturnType>(\n      fn: Promise<ReturnType> | (() => ReturnType | Promise<ReturnType>),\n      type: string,\n      desc?: string\n    ) => Promise<ReturnType>,\n    args: LoaderFunctionArgs\n  ) => Promise<Data>\n) {\n  return async function loader(args: LoaderFunctionArgs) {\n    const timings = makeTimings(timingsKey);\n\n    async function localTime<ReturnType>(\n      fn: Promise<ReturnType> | (() => ReturnType | Promise<ReturnType>),\n      type: string,\n      desc?: string\n    ) {\n      return time(fn, { timings, type, desc });\n    }\n\n    const result = await dataFn(localTime, args);\n\n    // Assuming you want to return the result and the timings\n    return new Response(JSON.stringify(result), {\n      headers: {\n        'Content-Type': 'application/json',\n        'Server-Timing': getServerTimeHeader(timings),\n      },\n    });\n  };\n}\n```\n\nThis implementation does the following:\n\n1. It takes two parameters: `timingsKey` (a string) and `dataFn` (a function).\n2. The `dataFn` is typed to accept two parameters:\n   - `time`: A function matching the signature of `localTime`\n   - `args`: The `LoaderFunctionArgs` from Remix\n3. It returns an async function that serves as the Remix loader.\n4. Inside the loader, it creates the `timings` and `localTime` function as before.\n5. It calls the `dataFn` with `localTime` and the loader args.\n6. Finally, it returns a `Response` with the result and the timing header.\n\nYou can use this function like this:\n\n```typescript\nexport const loader = loaderWithTimings(\"myKey\", async (time, { context, request }) => {\n  // Use the time function here\n  const data = await time(\n    () => fetchSomeData(),\n    \"fetchData\",\n    \"Fetching some data\"\n  );\n\n  return { data };\n});\n```\n\nThis setup allows you to use the `time` function within your loader while also capturing the timings automatically. The loader will return a Response with the correct headers for server timing.\nIs it able to be done without having to duplicate the types of the callback and the internal function? Can they be extract to a single type?\nAbsolutely! You can extract the common types to reduce duplication and improve maintainability. Here's an improved version using a shared type:\n\n```typescript\nimport type { LoaderFunctionArgs } from \"@remix-run/cloudflare\";\n\n// Define a type for the time function\ntype TimeFunction = <ReturnType>(\n  fn: Promise<ReturnType> | (() => ReturnType | Promise<ReturnType>),\n  type: string,\n  desc?: string\n) => Promise<ReturnType>;\n\n// Define a type for the data function\ntype DataFunction<Data> = (\n  time: TimeFunction,\n  args: LoaderFunctionArgs\n) => Promise<Data>;\n\nexport function loaderWithTimings<Data>(\n  timingsKey: string,\n  dataFn: DataFunction<Data>\n) {\n  return async function loader(args: LoaderFunctionArgs) {\n    const timings = makeTimings(timingsKey);\n\n    const localTime: TimeFunction = async (fn, type, desc) => {\n      return time(fn, { timings, type, desc });\n    };\n\n    const result = await dataFn(localTime, args);\n\n    return new Response(JSON.stringify(result), {\n      headers: {\n        'Content-Type': 'application/json',\n        'Server-Timing': getServerTimeHeader(timings),\n      },\n    });\n  };\n}\n```\n\nIn this version:\n\n1. We define `TimeFunction` which represents the signature of the `time` function.\n2. We define `DataFunction<Data>` which represents the signature of the data function passed to `loaderWithTimings`.\n3. We use these types in the `loaderWithTimings` function, reducing duplication and ensuring type consistency.\n\nYou can use this function the same way as before:\n\n```typescript\nexport const loader = loaderWithTimings<YourDataType>(\"myKey\", async (time, { context, request }) => {\n  const data = await time(\n    () => fetchSomeData(),\n    \"fetchData\",\n    \"Fetching some data\"\n  );\n\n  return { data };\n});\n```\n\nThis approach gives you:\n\n1. Type safety for the `time` function and loader arguments.\n2. Reusable types that can be used elsewhere if needed.\n3. Cleaner, more maintainable code with less type duplication.\n\nThe TypeScript compiler will infer the correct types for `time` and the loader arguments, providing proper type checking and autocompletion in your IDE.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":302}},"image_offsets":[]},{"id":{"replica_id":0,"value":208},"start":4008,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":303}},"image_offsets":[]},{"id":{"replica_id":0,"value":209},"start":6170,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":304}},"image_offsets":[]},{"id":{"replica_id":0,"value":274},"start":6311,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":300}},"image_offsets":[]},{"id":{"replica_id":0,"value":275},"start":8430,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":301}},"image_offsets":[]}],"summary":"Implementing loaderWithTimings function for Remix loaders","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":2,"end":3681},"icon":"File","label":"omorovicza-app/app/utils/timings/index.server.ts"},{"range":{"start":3426,"end":3681},"icon":"ExclamationTriangle","label":"Diagnostics (omorovicza-app/app/utils/timings/index.server.ts): 1 errors"},{"range":{"start":3488,"end":3680},"icon":"XCircle","label":"Type expected."}]}